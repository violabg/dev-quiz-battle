-- Users table (extends Supabase auth users)
create table public.profiles (
  id uuid not null references auth.users on delete cascade,
  name text,
  full_name text,
  user_name text,
  avatar_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  primary key (id)
);

alter table public.profiles enable row level security;

-- inserts a row into public.profiles
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = ''
as $$
begin
  insert into public.profiles (
    id,
    name,
    full_name,
    user_name,
    avatar_url
  )
  values (
    new.id,
    new.raw_user_meta_data ->> 'name',
    new.raw_user_meta_data ->> 'full_name',
    new.raw_user_meta_data ->> 'user_name',
    new.raw_user_meta_data ->> 'avatar_url'
  );
  return new;
end;
$$;
-- Generated by Copilot

-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Games table
CREATE TABLE IF NOT EXISTS games (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  code TEXT UNIQUE NOT NULL,
  host_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  status TEXT NOT NULL CHECK (status IN ('waiting', 'active', 'completed')),
  max_players INTEGER NOT NULL DEFAULT 8,
  current_turn INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  time_limit INTEGER NOT NULL DEFAULT 120
);

-- Game players
CREATE TABLE IF NOT EXISTS game_players (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  game_id UUID REFERENCES games(id) ON DELETE CASCADE,
  player_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  score DECIMAL(10, 2) NOT NULL DEFAULT 0,
  turn_order INTEGER NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(game_id, player_id)
);

-- Questions table
CREATE TABLE IF NOT EXISTS questions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  game_id UUID REFERENCES games(id) ON DELETE CASCADE,
  created_by_player_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  language TEXT NOT NULL,
  difficulty TEXT NOT NULL CHECK (difficulty IN ('easy', 'medium', 'hard', 'expert')),
  question_text TEXT NOT NULL,
  code_sample TEXT,
  options JSONB NOT NULL,
  correct_answer INTEGER NOT NULL,
  explanation TEXT,
  started_at TIMESTAMP WITH TIME ZONE,
  ended_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Answers table
CREATE TABLE IF NOT EXISTS answers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  question_id UUID REFERENCES questions(id) ON DELETE CASCADE,
  player_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  selected_option INTEGER NOT NULL,
  is_correct BOOLEAN NOT NULL,
  response_time_ms INTEGER NOT NULL,
  score_earned DECIMAL(10, 2) NOT NULL DEFAULT 0,
  answered_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(question_id, player_id)
);

-- Create function to generate unique game codes
CREATE OR REPLACE FUNCTION public.generate_unique_game_code()
RETURNS text
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = '' 
AS $$
DECLARE
  chars TEXT := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  result TEXT := '';
  i INTEGER := 0;
  pos INTEGER := 0;
BEGIN
   FOR i IN 1..6 LOOP
    pos := 1 + FLOOR(RANDOM() * LENGTH(chars));
    result := result || SUBSTRING(chars FROM pos FOR 1);
  END LOOP;
  RETURN result;
END;
$$;

-- Create trigger to automatically generate game codes
CREATE OR REPLACE FUNCTION set_game_code()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.code IS NULL OR NEW.code = '' THEN
    LOOP
      NEW.code := generate_unique_game_code();
      EXIT WHEN NOT EXISTS (SELECT 1 FROM games WHERE code = NEW.code);
    END LOOP;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_set_game_code
BEFORE INSERT ON games
FOR EACH ROW
EXECUTE FUNCTION set_game_code();

-- Create function to calculate score based on response time
CREATE OR REPLACE FUNCTION calculate_score(
  response_time_ms INTEGER,
  time_limit_ms INTEGER
)
RETURNS DECIMAL 
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = '' 
AS $$
DECLARE
  base_score DECIMAL := 1.0;
  time_bonus DECIMAL := 0.0;
  t1 DECIMAL := time_limit_ms * 0.05;   -- 5%
  t2 DECIMAL := time_limit_ms * 0.10;   -- 10%
  t3 DECIMAL := time_limit_ms * 0.15;   -- 15%
  t4 DECIMAL := time_limit_ms * 0.20;   -- 20%
  t5 DECIMAL := time_limit_ms * 0.30;   -- 30%
  t6 DECIMAL := time_limit_ms * 0.40;   -- 40%
  t7 DECIMAL := time_limit_ms * 0.55;   -- 55%
  t8 DECIMAL := time_limit_ms * 0.70;   -- 70%
  t9 DECIMAL := time_limit_ms * 0.85;   -- 85%
  t10 DECIMAL := time_limit_ms;         -- 100%
BEGIN
  IF response_time_ms < t1 THEN
    time_bonus := 9.0;
  ELSIF response_time_ms < t2 THEN
    time_bonus := 8.0;
  ELSIF response_time_ms < t3 THEN
    time_bonus := 7.0;
  ELSIF response_time_ms < t4 THEN
    time_bonus := 6.0;
  ELSIF response_time_ms < t5 THEN
    time_bonus := 5.0;
  ELSIF response_time_ms < t6 THEN
    time_bonus := 4.0;
  ELSIF response_time_ms < t7 THEN
    time_bonus := 3.0;
  ELSIF response_time_ms < t8 THEN
    time_bonus := 2.0;
  ELSIF response_time_ms < t9 THEN
    time_bonus := 1.0;
  ELSIF response_time_ms < t10 THEN
    time_bonus := 0.5;
  END IF;

  RETURN base_score + time_bonus;
END;
$$;

-- Create function to submit answer and update score atomically
CREATE OR REPLACE FUNCTION submit_answer(
  p_question_id UUID,
  p_player_id UUID,
  p_game_id UUID,
  p_selected_option INTEGER,
  p_is_correct BOOLEAN,
  p_response_time_ms INTEGER,
  p_score_earned DECIMAL
)
RETURNS UUID
SECURITY DEFINER
AS $$
DECLARE
  v_answer_id UUID;
BEGIN
  -- Insert answer
  INSERT INTO answers (
    question_id,
    player_id,
    selected_option,
    is_correct,
    response_time_ms,
    score_earned
  )
  VALUES (
    p_question_id,
    p_player_id,
    p_selected_option,
    p_is_correct,
    p_response_time_ms,
    p_score_earned
  )
  RETURNING id INTO v_answer_id;

  -- Update player score if correct
  IF p_is_correct THEN
    UPDATE game_players
    SET score = score + p_score_earned
    WHERE game_id = p_game_id AND player_id = p_player_id;
  END IF;

  RETURN v_answer_id;
END;
$$ LANGUAGE plpgsql;

-- Leaderboard function: sum scores per player, join profile, paginated
CREATE OR REPLACE FUNCTION get_leaderboard_players(
  offset_value integer,
  limit_value integer
)
RETURNS TABLE (
  player_id uuid,
  total_score numeric,
  user_name text,
  avatar_url text
) AS $$
BEGIN
  RETURN QUERY
    SELECT
      gp.player_id,
      SUM(gp.score) AS total_score,
      p.user_name,
      p.avatar_url
    FROM game_players gp
    JOIN profiles p ON gp.player_id = p.id
    GROUP BY gp.player_id, p.user_name, p.avatar_url
    ORDER BY total_score DESC
    LIMIT limit_value OFFSET offset_value;  -- Corrected order of LIMIT and OFFSET
END;
$$ LANGUAGE plpgsql;

-- Function to user details with player scores
CREATE OR REPLACE FUNCTION get_user_profile_with_score(user_id uuid)
RETURNS TABLE(profile_id uuid, user_name text, avatar_url text, total_score bigint) AS $$
BEGIN
    RETURN QUERY
    SELECT p.id, p.user_name, p.avatar_url, COALESCE(SUM(gp.score)::bigint, 0) AS total_score
    FROM profiles p
    LEFT JOIN game_players gp ON p.id = gp.player_id
    WHERE p.id = user_id
    GROUP BY p.id;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

-- Policies for row-level security
CREATE POLICY "Allow authenticated and anonymous users to select profiles" 
ON profiles 
FOR SELECT 
TO authenticated, anon 
USING (true);